# Copyright (C) 2012 Johan Hake (hake.dev@gmail.com)
# Use and modify at will
# Last changed: 2013-04-19


__all__ = ["gotran2cellmodel"]

try:
    import gotran

except Exception, e:
    print "Not possible to convert gotran model to cellmodel."
    raise e

# Gotran imports
from gotran.codegeneration.codegenerator import CodeGenerator
from gotran.common import error as gotran_error, check_arg

_class_template = """
\"\"\"This module contains a {ModelName} cardiac cell model

The module was autogenerated from a gotran form file
\"\"\"
from __future__ import division
from collections import OrderedDict
import ufl

from dolfin import *
from dolfin_adjoint import *

from beatadjoint.cellmodels import CardiacCellModel

class {ModelName}(CardiacCellModel):
    \"\"\"
{CLASSDOC}
    \"\"\"
    def __init__(self, params=None, init_conditions=None):
        \"\"\"
        Create cardiac cell model

        *Arguments*
         params (dict, :py:class:`dolfin.Mesh`, optional)
           optional model parameters
         init_conditions (dict, :py:class:`dolfin.Mesh`, optional)
           optional initial conditions
        \"\"\"
        CardiacCellModel.__init__(self, params, init_conditions)

    @staticmethod
    def default_parameters():
        \"Set-up and return default parameters.\"
{default_parameters}
        return params

    @staticmethod
    def default_initial_conditions():
        \"Set-up and return default initial conditions.\"
{initial_conditions}
        return ic

    def I(self, v, s, time=None):
        \"\"\"
        Transmembrane current
        \"\"\"
{I_body}
        return current

    def F(self, v, s, time=None):
        \"\"\"
        Right hand side for ODE system
        \"\"\"
{F_body}
        return as_vector(F_expressions) if _is_vector else F_expressions[0]

    def num_states(self):
        return {num_states}

    def __str__(self):
        return '{ModelName} cardiac cell model'
"""

_class_form = dict(
  ModelName="NOT_IMPLEMENTED",
  CLASSDOC="NOT_IMPLEMENTED",
  default_parameters="NOT_IMPLEMENTED",
  I_body="NOT_IMPLEMENTED",
  F_body="NOT_IMPLEMENTED",
  num_states="NOT_IMPLEMENTED",
  initial_conditions="NOT_IMPLEMENTED",
)

class CellModelGenerator(CodeGenerator):
    """
    Convert a Gotran model to a beat-adjoint compatible cell model
    """
    def __init__(self, oderepr, membrane_potential):
        
        # Init base class
        super(CellModelGenerator, self).__init__(oderepr)
        
        check_arg(membrane_potential, str, 1)

        # Get ode
        ode = oderepr.ode
        
        assert(not ode.is_dae)

        # Capitalize first letter of name
        name = oderepr.name
        self._name = name if name[0].isupper() else name[0].upper() + \
                     (name[1:] if len(name) > 1 else "")
        
        # Check we use correct ODERepresentation optimizations
        optimizations = [("use_state_names", True),
                         ("use_parameter_names", True),
                         ("keep_intermediates", False),
                         ("parameter_numerals", False),
                         ("use_cse", False)]

        for what, value in optimizations:
            if oderepr.optimization[what] != value:
                gotran_error("Got wrong optimization of ODERepresentation."\
                             " Expected {0} for '{1}' got {2}".format(\
                                 value, what, oderepr.optimization[what]))
        if ode.num_states < 2:
            gotran_error("expected the ODE to have more than 1 state")

        # Check that ode model has the membrane potential state name
        state = ode.get_object(membrane_potential)
        if not isinstance(state, gotran.model.State):
            gotran_error("Cannot find the membrane potential. ODE does not "\
                         "contain a state with name '{0}'".format(\
                             membrane_potential))
        
        # The name of the membrane potential
        self.V_name = state.name

        all_derivatives = [(derivatives[0], expr) for derivatives, expr \
                           in oderepr.iter_derivative_expr()]
    
        # Get the I and F expressions
        self._I_expression = [expr for derivatives, expr in all_derivatives \
                              if derivatives.name == self.V_name][0]

        # I(v,s) in gotran is given by dv_dt = I(v,s) but a beat cell model
        # wants dv_dt = -I(v,s)
        self._I_expression *= -1

        # Get the used parameters
        I_used_parameters = set()
        for param in ode.parameters:
            
            if param.sym in self._I_expression.atoms():
                I_used_parameters.add(param.name)
        
        self._I_used_parameters = list(I_used_parameters)
        
        self._F_expressions = [(derivatives.name, expr) \
                               for derivatives, expr in all_derivatives \
                               if derivatives.name != self.V_name]

        # Get the used parameters
        F_used_parameters = set()
        for param in ode.parameters:

            for state, expr in self._F_expressions:
                if param.sym in expr.atoms():
                    F_used_parameters.add(param.name)
        self._F_used_parameters = list(F_used_parameters)

        self.oderepr = oderepr

        # Create the class form and start fill it
        self._class_form = _class_form.copy()

        self._class_form["num_states"] = ode.num_states - 1
        self._class_form["ModelName"] = self.name
        self._class_form["default_parameters"] = self.default_parameters_body()
        self._class_form["F_body"] = self.F_body()
        self._class_form["I_body"] = self.I_body()
        self._class_form["initial_conditions"] = self.initial_conditions_body()

    @property
    def name(self):
        return self._name

    def generate(self):
        """
        Return a beat cell model file as a str
        """
        return _class_template.format(**self._class_form)
    
    def _common_body(self):
        """
        Return a common body for both I and F methods
        """
        ode = self.oderepr.ode

        body_lines = ["# Imports", "# No imports for now"]
        body_lines.append("")
        body_lines.append("time = time if time else Constant(0.0)")
        body_lines.append("# Assign states")
        if self.V_name != "v":
            body_lines.append("{0} = v".format(self.V_name))
        #body_lines.append("states = split(s)")
        states = [state.name for state in ode.states \
                 if state.name != self.V_name]
        if len(states) == 1:
            body_lines.append("_is_vector = False")
            if states[0] != "s":
                body_lines.append("{0} = s".format(states[0]))
        else:
            body_lines.append("_is_vector = True")
            #body_lines.append("states = s")
            body_lines.append("assert(len(s) == {0})".format(ode.num_states-1))
            body_lines.append(", ".join(states) + " = s")
        body_lines.append("")
        
        return body_lines

    def I_body(self):
        """
        Generate code for the I body
        """

        from modelparameters.codegeneration import pythoncode

        # Get common body
        body_lines = self._common_body()

        body_lines.append("# Assign parameters")
        for param in self._I_used_parameters:
            body_lines.append("{0} = self._parameters["\
                              "\"{1}\"]".format(param, param))
        body_lines.append("")
        body_lines.append(pythoncode(self._I_expression, "current", namespace="ufl"))
        body_lines.append("")
        
        return "\n".join(self.indent_and_split_lines(body_lines, 2))

    def F_body(self):
        """
        Generate code for the F body
        """

        from modelparameters.codegeneration import pythoncode

        # Get common body
        body_lines = self._common_body()

        body_lines.append("# Assign parameters")
        for param in self._F_used_parameters:
            body_lines.append("{0} = self._parameters["\
                              "\"{1}\"]".format(param, param))
        body_lines.append("")
        body_lines.append("F_expressions = [\\")
        for state, expr in self._F_expressions:
            body_lines.append("")
            body_lines.append("    # Derivative for state {0}".format(state))
            body_lines.append("    {0},".format(pythoncode(expr, namespace="ufl")))
        body_lines.append("    ]")
        body_lines.append("")

        return "\n".join(self.indent_and_split_lines(body_lines, 2))

    def default_parameters_body(self):
        """
        Generate code for the default parameter bod
        """
        ode = self.oderepr.ode
        if ode.num_parameters>0:

            params = ode.parameters[:]

            param = params.pop(0)
            
            body_lines = ["params = OrderedDict([(\"{}\", {}),".format(\
                param.name, param.init)]
            body_lines.extend("                      (\"{}\", {}),".format(\
                param.name, param.init if isinstance(param.init, (float, int))\
                                 else param.init[0]) for param in params)
            body_lines[-1] = body_lines[-1][0:-1]+"])"
        else:
            body_lines = ["params = OrderedDict()"]
            
        return "\n".join(self.indent_and_split_lines(body_lines, 2))
        
    def initial_conditions_body(self):
        """
        Generate code for the ic body
        """

        ode = self.oderepr.ode
        
        # First get ic for v
        v_init = ode.get_object(self.V_name).init
        if not isinstance(v_init, (float, int)):
            v_init = v_init[0]
        s_init, s_names = zip(*[(state.init if isinstance(state.init, (float, int))\
                                 else state.init[0], state.name) for state in ode.states \
                                if state.name != self.V_name])
        body_lines = ["ic = OrderedDict([(\"{}\", {}),".format(\
            self.V_name, v_init)]
        body_lines.extend("                  (\"{}\", {}),".format(name, value) \
                          for name, value in zip(s_names, s_init))
        body_lines[-1] = body_lines[-1][0:-1]+"])"

        return "\n".join(self.indent_and_split_lines(body_lines, 2))
