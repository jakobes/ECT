
"""This module contains a Tentusscher_2004_mcell cardiac cell model

The module was autogenerated from a gotran form file
"""
from __future__ import division
from collections import OrderedDict
import ufl

from dolfin import *
from dolfin_adjoint import *

from beatadjoint.cellmodels import CardiacCellModel

class Tentusscher_2004_mcell(CardiacCellModel):
    """
NOT_IMPLEMENTED
    """
    def __init__(self, params=None, init_conditions=None):
        """
        Create cardiac cell model

        *Arguments*
         params (dict, :py:class:`dolfin.Mesh`, optional)
           optional model parameters
         init_conditions (dict, :py:class:`dolfin.Mesh`, optional)
           optional initial conditions
        """
        CardiacCellModel.__init__(self, params, init_conditions)

    @staticmethod
    def default_parameters():
        "Set-up and return default parameters."
        params = OrderedDict([("P_kna", 0.03),
                              ("g_K1", 5.405),
                              ("g_Kr", 0.096),
                              ("g_Ks", 0.062),
                              ("g_Na", 14.838),
                              ("g_bna", 0.00029),
                              ("g_CaL", 0.000175),
                              ("g_bca", 0.000592),
                              ("g_to", 0.294),
                              ("K_mNa", 40),
                              ("K_mk", 1),
                              ("P_NaK", 1.362),
                              ("K_NaCa", 1000),
                              ("K_sat", 0.1),
                              ("Km_Ca", 1.38),
                              ("Km_Nai", 87.5),
                              ("alpha", 2.5),
                              ("gamma", 0.35),
                              ("K_pCa", 0.0005),
                              ("g_pCa", 0.825),
                              ("g_pK", 0.0146),
                              ("Buf_c", 0.15),
                              ("Buf_sr", 10),
                              ("Ca_o", 2),
                              ("K_buf_c", 0.001),
                              ("K_buf_sr", 0.3),
                              ("K_up", 0.00025),
                              ("V_leak", 8e-05),
                              ("V_sr", 0.001094),
                              ("Vmax_up", 0.000425),
                              ("a_rel", 0.016464),
                              ("b_rel", 0.25),
                              ("c_rel", 0.008232),
                              ("tau_g", 2),
                              ("Na_o", 140),
                              ("Cm", 0.185),
                              ("F", 96485.3415),
                              ("R", 8314.472),
                              ("T", 310),
                              ("V_c", 0.016404),
                              ("stim_amplitude", 0),
                              ("stim_duration", 1),
                              ("stim_period", 1000),
                              ("stim_start", 1),
                              ("K_o", 5.4)])
        return params

    @staticmethod
    def default_initial_conditions():
        "Set-up and return default initial conditions."
        ic = OrderedDict([("V", -86.2),
                          ("Xr1", 0),
                          ("Xr2", 1),
                          ("Xs", 0),
                          ("m", 0),
                          ("h", 0.75),
                          ("j", 0.75),
                          ("d", 0),
                          ("f", 1),
                          ("fCa", 1),
                          ("s", 1),
                          ("r", 0),
                          ("Ca_SR", 0.2),
                          ("Ca_i", 0.0002),
                          ("g", 1),
                          ("Na_i", 11.6),
                          ("K_i", 138.3)])
        return ic

    def I(self, v, s, time=None):
        """
        Transmembrane current
        """
        # Imports
        # No imports for now

        time = time if time else Constant(0.0)
        # Assign states
        V = v
        _is_vector = True
        assert(len(s) == 16)
        Xr1, Xr2, Xs, m, h, j, d, f, fCa, s, r, Ca_SR, Ca_i, g, Na_i, K_i = s

        # Assign parameters
        g_bca = self._parameters["g_bca"]
        g_CaL = self._parameters["g_CaL"]
        stim_start = self._parameters["stim_start"]
        K_o = self._parameters["K_o"]
        Ca_o = self._parameters["Ca_o"]
        g_pCa = self._parameters["g_pCa"]
        g_Ks = self._parameters["g_Ks"]
        g_Kr = self._parameters["g_Kr"]
        stim_amplitude = self._parameters["stim_amplitude"]
        P_kna = self._parameters["P_kna"]
        K_pCa = self._parameters["K_pCa"]
        P_NaK = self._parameters["P_NaK"]
        Km_Nai = self._parameters["Km_Nai"]
        g_to = self._parameters["g_to"]
        K_mNa = self._parameters["K_mNa"]
        F = self._parameters["F"]
        g_bna = self._parameters["g_bna"]
        Na_o = self._parameters["Na_o"]
        R = self._parameters["R"]
        T = self._parameters["T"]
        alpha = self._parameters["alpha"]
        K_sat = self._parameters["K_sat"]
        K_NaCa = self._parameters["K_NaCa"]
        g_pK = self._parameters["g_pK"]
        g_K1 = self._parameters["g_K1"]
        Km_Ca = self._parameters["Km_Ca"]
        g_Na = self._parameters["g_Na"]
        stim_duration = self._parameters["stim_duration"]
        K_mk = self._parameters["K_mk"]
        gamma = self._parameters["gamma"]

        current = (Xs*Xs)*(V - R*T*ufl.ln((Na_o*P_kna + K_o)/(P_kna*Na_i +\
            K_i))/F)*g_Ks + Ca_i*g_pCa/(Ca_i + K_pCa) + (V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_pK/(1.0 +\
            65.4052157419383*ufl.exp(-0.167224080267559*V)) +\
            K_o*P_NaK*Na_i/((K_mk + K_o)*(Na_i + K_mNa)*(1.0 +\
            0.1245*ufl.exp(-0.1*F*V/(R*T)) + 0.0353*ufl.exp(-F*V/(R*T)))) +\
            (V - R*T*ufl.ln(Na_o/Na_i)/F)*g_bna +\
            0.430331482911935*ufl.sqrt(K_o)*(V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_Kr*Xr1*Xr2 + (V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_to*r*s + (m*m*m)*(V -\
            R*T*ufl.ln(Na_o/Na_i)/F)*g_Na*h*j +\
            (-(Na_o*Na_o*Na_o)*Ca_i*alpha*ufl.exp((-1.0 + gamma)*F*V/(R*T)) +\
            (Na_i*Na_i*Na_i)*Ca_o*ufl.exp(F*gamma*V/(R*T)))*K_NaCa/((1.0 +\
            K_sat*ufl.exp((-1.0 + gamma)*F*V/(R*T)))*((Na_o*Na_o*Na_o) +\
            (Km_Nai*Km_Nai*Km_Nai))*(Km_Ca + Ca_o)) + 4.0*(F*F)*(-0.341*Ca_o\
            + Ca_i*ufl.exp(2.0*F*V/(R*T)))*g_CaL*V*d*f*fCa/((-1.0 +\
            ufl.exp(2.0*F*V/(R*T)))*R*T) +\
            0.0430331482911935*ufl.sqrt(K_o)*(V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_K1/((1.0 +\
            6.14421235332821e-6*ufl.exp(0.06*V -\
            0.06*R*T*ufl.ln(K_o/K_i)/F))*(0.1/(1.0 +\
            6.14421235332821e-6*ufl.exp(0.06*V - 0.06*R*T*ufl.ln(K_o/K_i)/F))\
            + (3.06060402008027*ufl.exp(0.0002*V -\
            0.0002*R*T*ufl.ln(K_o/K_i)/F) +\
            0.367879441171442*ufl.exp(-0.1*R*T*ufl.ln(K_o/K_i)/F +\
            0.1*V))/(1.0 + ufl.exp(0.5*R*T*ufl.ln(K_o/K_i)/F - 0.5*V)))) + (V\
            - 0.5*R*T*ufl.ln(Ca_o/Ca_i)/F)*g_bca - (1.0 - 1.0/(1.0 +\
            ufl.exp(-5.0*stim_start + 5.0*time)))*stim_amplitude/(1.0 +\
            ufl.exp(-5.0*stim_start + 5.0*time - 5.0*stim_duration))

        return current

    def F(self, v, s, time=None):
        """
        Right hand side for ODE system
        """
        # Imports
        # No imports for now

        time = time if time else Constant(0.0)
        # Assign states
        V = v
        _is_vector = True
        assert(len(s) == 16)
        Xr1, Xr2, Xs, m, h, j, d, f, fCa, s, r, Ca_SR, Ca_i, g, Na_i, K_i = s

        # Assign parameters
        Buf_c = self._parameters["Buf_c"]
        g_bca = self._parameters["g_bca"]
        stim_amplitude = self._parameters["stim_amplitude"]
        K_o = self._parameters["K_o"]
        g_CaL = self._parameters["g_CaL"]
        a_rel = self._parameters["a_rel"]
        stim_start = self._parameters["stim_start"]
        c_rel = self._parameters["c_rel"]
        K_up = self._parameters["K_up"]
        V_sr = self._parameters["V_sr"]
        Ca_o = self._parameters["Ca_o"]
        g_pCa = self._parameters["g_pCa"]
        g_Ks = self._parameters["g_Ks"]
        g_Kr = self._parameters["g_Kr"]
        Vmax_up = self._parameters["Vmax_up"]
        P_kna = self._parameters["P_kna"]
        K_pCa = self._parameters["K_pCa"]
        P_NaK = self._parameters["P_NaK"]
        V_c = self._parameters["V_c"]
        V_leak = self._parameters["V_leak"]
        Km_Nai = self._parameters["Km_Nai"]
        g_to = self._parameters["g_to"]
        Buf_sr = self._parameters["Buf_sr"]
        K_mNa = self._parameters["K_mNa"]
        F = self._parameters["F"]
        g_bna = self._parameters["g_bna"]
        K_buf_sr = self._parameters["K_buf_sr"]
        Na_o = self._parameters["Na_o"]
        b_rel = self._parameters["b_rel"]
        T = self._parameters["T"]
        alpha = self._parameters["alpha"]
        K_sat = self._parameters["K_sat"]
        K_buf_c = self._parameters["K_buf_c"]
        K_NaCa = self._parameters["K_NaCa"]
        g_pK = self._parameters["g_pK"]
        Cm = self._parameters["Cm"]
        g_K1 = self._parameters["g_K1"]
        Km_Ca = self._parameters["Km_Ca"]
        R = self._parameters["R"]
        g_Na = self._parameters["g_Na"]
        tau_g = self._parameters["tau_g"]
        stim_duration = self._parameters["stim_duration"]
        K_mk = self._parameters["K_mk"]
        gamma = self._parameters["gamma"]

        F_expressions = [\

            # Derivative for state Xr1
            0.00037037037037037*(1.0 +\
            13.5813245225782*ufl.exp(0.0869565217391304*V))*(1.0 +\
            ufl.exp(-9/2 - V/10.0))*(1.0/(1.0 +\
            0.0243728440732796*ufl.exp(-0.142857142857143*V)) - Xr1),

            # Derivative for state Xr2
            0.297619047619048*(1.0 + 0.0497870683678639*ufl.exp(0.05*V))*(1.0 +\
            0.0497870683678639*ufl.exp(-0.05*V))*(1.0/(1.0 +\
            39.1212839981532*ufl.exp(0.0416666666666667*V)) - Xr2),

            # Derivative for state Xs
            0.000909090909090909*ufl.sqrt(1.0 +\
            0.188875602837562*ufl.exp(-0.166666666666667*V))*(1.0 +\
            0.0497870683678639*ufl.exp(0.05*V))*(-Xs + 1.0/(1.0 +\
            0.69967253737513*ufl.exp(-0.0714285714285714*V))),

            # Derivative for state m
            (1.0 + ufl.exp(-12.0 - V/5.0))*(1.0/((1.0 +\
            0.00184221158116513*ufl.exp(-0.110741971207087*V))*(1.0 +\
            0.00184221158116513*ufl.exp(-0.110741971207087*V))) -\
            m)/(0.1/(1.0 + 0.778800783071405*ufl.exp(0.005*V)) + 0.1/(1.0 +\
            ufl.exp(7.0 + V/5.0))),

            # Derivative for state h
            (1.0/((1.0 + 15212.5932856544*ufl.exp(0.134589502018843*V))*(1.0 +\
            15212.5932856544*ufl.exp(0.134589502018843*V))) -\
            h)*(4.43126792958051e-7*ufl.exp(-0.147058823529412*V)/(1.0 +\
            2.3538526683702e+17*ufl.exp(1.0*V)) + 0.77*(1.0 - 1.0/(1.0 +\
            2.3538526683702e+17*ufl.exp(1.0*V)))/(0.13 +\
            0.0497581410839387*ufl.exp(-0.0900900900900901*V)) +\
            (2.7*ufl.exp(0.079*V) + 310000.0*ufl.exp(0.3485*V))/(1.0 +\
            2.3538526683702e+17*ufl.exp(1.0*V))),

            # Derivative for state j
            (1.0/((1.0 + 15212.5932856544*ufl.exp(0.134589502018843*V))*(1.0 +\
            15212.5932856544*ufl.exp(0.134589502018843*V))) - j)*((37.78 +\
            V)*(-25428.0*ufl.exp(0.2444*V) -\
            6.948e-6*ufl.exp(-0.04391*V))/((1.0 +\
            2.3538526683702e+17*ufl.exp(1.0*V))*(1.0 +\
            50262745825.954*ufl.exp(0.311*V))) +\
            0.02424*ufl.exp(-0.01052*V)/((1.0 +\
            2.3538526683702e+17*ufl.exp(1.0*V))*(1.0 +\
            0.00396086833990426*ufl.exp(-0.1378*V))) + 0.6*(1.0 - 1.0/(1.0 +\
            2.3538526683702e+17*ufl.exp(1.0*V)))*ufl.exp(0.057*V)/(1.0 +\
            0.0407622039783662*ufl.exp(-0.1*V))),

            # Derivative for state d
            (-d + 1.0/(1.0 +\
            0.513417119032592*ufl.exp(-0.133333333333333*V)))/(1.0/(1.0 +\
            12.1824939607035*ufl.exp(-0.05*V)) + 1.4*(0.25 + 1.4/(1.0 +\
            0.0677244716592409*ufl.exp(-0.0769230769230769*V)))/(1.0 +\
            ufl.exp(1.0 + V/5.0))),

            # Derivative for state f
            (1.0/(1.0 + 17.4117080633276*ufl.exp(0.142857142857143*V)) -\
            f)/(80.0 + 1125.0*ufl.exp(-0.00416666666666667*((27.0 + V)*(27.0 +\
            V))) + 165.0/(1.0 + ufl.exp(5/2 - V/10.0))),

            # Derivative for state fCa
            (1.0 - 1.0/((1.0 + 4.8323962649919*ufl.exp(-10.0*fCa +\
            6.84931506849315/(1.0 + 8.03402376701711e+27*ufl.elem_pow(Ca_i,\
            8.0)) + 0.684931506849315/(1.0 +\
            0.00673794699908547*ufl.exp(10000.0*Ca_i)) +\
            1.36986301369863/(1.0 +\
            0.391605626676799*ufl.exp(1250.0*Ca_i))))*(1.0 + ufl.exp(60.0 +\
            V))))*(0.0787671232876712 + 0.0342465753424658/(1.0 +\
            0.00673794699908547*ufl.exp(10000.0*Ca_i)) +\
            0.0684931506849315/(1.0 + 0.391605626676799*ufl.exp(1250.0*Ca_i))\
            - fCa/2.0 + 0.342465753424658/(1.0 +\
            8.03402376701711e+27*ufl.elem_pow(Ca_i, 8.0))),

            # Derivative for state s
            (1.0/(1.0 + ufl.exp(4.0 + V/5.0)) - s)/(3.0 + 5.0/(1.0 +\
            ufl.exp(-4.0 + V/5.0)) + 85.0*ufl.exp(-0.003125*((45.0 + V)*(45.0 +\
            V)))),

            # Derivative for state r
            (1.0/(1.0 + 28.0316248945261*ufl.exp(-0.166666666666667*V)) -\
            r)/(0.8 + 9.5*ufl.exp(-0.000555555555555556*((40.0 + V)*(40.0 +\
            V)))),

            # Derivative for state Ca_SR
            (-(Ca_SR - Ca_i)*V_leak - (c_rel +\
            (Ca_SR*Ca_SR)*a_rel/((Ca_SR*Ca_SR) + (b_rel*b_rel)))*d*g +\
            Vmax_up/(1.0 + (K_up*K_up)/(Ca_i*Ca_i)))*V_c/((1.0 +\
            Buf_sr*K_buf_sr/((K_buf_sr + Ca_SR)*(K_buf_sr + Ca_SR)))*V_sr),

            # Derivative for state Ca_i
            (-(Ca_i*g_pCa/(Ca_i + K_pCa) -\
            2.0*(-(Na_o*Na_o*Na_o)*Ca_i*alpha*ufl.exp((-1.0 +\
            gamma)*F*V/(R*T)) +\
            (Na_i*Na_i*Na_i)*Ca_o*ufl.exp(F*gamma*V/(R*T)))*K_NaCa/((1.0 +\
            K_sat*ufl.exp((-1.0 + gamma)*F*V/(R*T)))*((Na_o*Na_o*Na_o) +\
            (Km_Nai*Km_Nai*Km_Nai))*(Km_Ca + Ca_o)) + 4.0*(F*F)*(-0.341*Ca_o\
            + Ca_i*ufl.exp(2.0*F*V/(R*T)))*g_CaL*V*d*f*fCa/((-1.0 +\
            ufl.exp(2.0*F*V/(R*T)))*R*T) + (V -\
            0.5*R*T*ufl.ln(Ca_o/Ca_i)/F)*g_bca)*Cm/(2.0*F*V_c) + (c_rel +\
            (Ca_SR*Ca_SR)*a_rel/((Ca_SR*Ca_SR) + (b_rel*b_rel)))*d*g -\
            Vmax_up/(1.0 + (K_up*K_up)/(Ca_i*Ca_i)) + (Ca_SR -\
            Ca_i)*V_leak)/(1.0 + Buf_c*K_buf_c/((Ca_i + K_buf_c)*(Ca_i +\
            K_buf_c))),

            # Derivative for state g
            (1.0 - 1.0/((1.0 + ufl.exp(60.0 + V))*(1.0 + ufl.exp(-10.0*g +\
            10.0*(1.0 - 1.0/(1.0 +\
            0.0301973834223185*ufl.exp(10000.0*Ca_i)))/(1.0 +\
            1.97201988740492e+55*ufl.elem_pow(Ca_i, 16.0)) + 10.0/((1.0 +\
            0.0301973834223185*ufl.exp(10000.0*Ca_i))*(1.0 +\
            5.43991024148102e+20*ufl.elem_pow(Ca_i, 6.0)))))))*((1.0 -\
            1.0/(1.0 + 0.0301973834223185*ufl.exp(10000.0*Ca_i)))/(1.0 +\
            1.97201988740492e+55*ufl.elem_pow(Ca_i, 16.0)) - g + 1.0/((1.0 +\
            0.0301973834223185*ufl.exp(10000.0*Ca_i))*(1.0 +\
            5.43991024148102e+20*ufl.elem_pow(Ca_i, 6.0))))/tau_g,

            # Derivative for state Na_i
            (-3.0*(-(Na_o*Na_o*Na_o)*Ca_i*alpha*ufl.exp((-1.0 +\
            gamma)*F*V/(R*T)) +\
            (Na_i*Na_i*Na_i)*Ca_o*ufl.exp(F*gamma*V/(R*T)))*K_NaCa/((1.0 +\
            K_sat*ufl.exp((-1.0 + gamma)*F*V/(R*T)))*((Na_o*Na_o*Na_o) +\
            (Km_Nai*Km_Nai*Km_Nai))*(Km_Ca + Ca_o)) -\
            3.0*K_o*P_NaK*Na_i/((K_mk + K_o)*(Na_i + K_mNa)*(1.0 +\
            0.1245*ufl.exp(-0.1*F*V/(R*T)) + 0.0353*ufl.exp(-F*V/(R*T)))) -\
            (m*m*m)*(V - R*T*ufl.ln(Na_o/Na_i)/F)*g_Na*h*j - (V -\
            R*T*ufl.ln(Na_o/Na_i)/F)*g_bna)*Cm/(F*V_c),

            # Derivative for state K_i
            ((1.0 - 1.0/(1.0 + ufl.exp(-5.0*stim_start +\
            5.0*time)))*stim_amplitude/(1.0 + ufl.exp(-5.0*stim_start +\
            5.0*time - 5.0*stim_duration)) - (V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_pK/(1.0 +\
            65.4052157419383*ufl.exp(-0.167224080267559*V)) - (Xs*Xs)*(V -\
            R*T*ufl.ln((Na_o*P_kna + K_o)/(P_kna*Na_i + K_i))/F)*g_Ks - (V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_to*r*s -\
            0.0430331482911935*ufl.sqrt(K_o)*(V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_K1/((1.0 +\
            6.14421235332821e-6*ufl.exp(0.06*V -\
            0.06*R*T*ufl.ln(K_o/K_i)/F))*(0.1/(1.0 +\
            6.14421235332821e-6*ufl.exp(0.06*V - 0.06*R*T*ufl.ln(K_o/K_i)/F))\
            + (3.06060402008027*ufl.exp(0.0002*V -\
            0.0002*R*T*ufl.ln(K_o/K_i)/F) +\
            0.367879441171442*ufl.exp(-0.1*R*T*ufl.ln(K_o/K_i)/F +\
            0.1*V))/(1.0 + ufl.exp(0.5*R*T*ufl.ln(K_o/K_i)/F - 0.5*V)))) +\
            2.0*K_o*P_NaK*Na_i/((K_mk + K_o)*(Na_i + K_mNa)*(1.0 +\
            0.1245*ufl.exp(-0.1*F*V/(R*T)) + 0.0353*ufl.exp(-F*V/(R*T)))) -\
            0.430331482911935*ufl.sqrt(K_o)*(V -\
            R*T*ufl.ln(K_o/K_i)/F)*g_Kr*Xr1*Xr2)*Cm/(F*V_c),
            ]

        return as_vector(F_expressions) if _is_vector else F_expressions[0]

    def num_states(self):
        return 16

    def __str__(self):
        return 'Tentusscher_2004_mcell cardiac cell model'
